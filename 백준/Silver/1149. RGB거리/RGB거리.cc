#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

int main(){
    int N;
    cin >> N;

    /*
    항상 최솟값을 선택하는 것이 최소비용임을 보장할수없다..

    i 시점에서 i - 1 또는 i + 1을 보고 합이최소가 되는 최소값을 선택하면 어떻게될까?
    
    예를들어서
    30 1 100
    100 1 100 이런 상황이면
    처음에 1을 선택하면 두개합쳐서 101인데
    처음에 30을 선택하면 코스트가 31이다.
    이런 경우를 어떻게 해야할까

    6번의 for문을 돌려서 두개 합이 최소가 되는걸로 하면?
    그럼 만약에
    30 1 40
    100 10 100
    100 1 100 이라고 치면

    다시생각해보면
    30 1 40
    100 10 100
    100 1 100 에서
    i+1 번째거를 보고 30을 선택한다.
    그럼 그다음에 100 10 100 에서
    i + 1을 보고 100을 선택할거다.
    즉 i + 1 을 보고 현재것 중에서 선택하도록 짜 보면 되지 않을까?
    그리고 이전에 뭘 선택했었는지도 저장해둘 임시 변수가 있어야 할 것 같다.




    결국 하루동안 삽질하다 지피티 봤다.

    결론 -> 내가 지금 집에 칠하는 색에 따른 비용을 구하고, 이를 비교하는게 답이다
    즉 i 시점에서 i - 1을 보면서, i 집을 빨강 파랑 초록으로 칠할 때 각각의 비용을 구하고
    이를 누적해서 더하고, 그중 최소값이 답이 된다.

    찝찝하다...

    
    */
    vector < vector < int > > cost (N, vector<int> (3, 0));
    vector < vector < int > > ans (N, vector < int> (3, 0)); //누적합이 저장될 배열
    for(int i = 0; i < N; i++){
        for(int j = 0; j < 3; j++){
            cin >> cost[i][j];
        }
    }

    ans[0][0] = cost[0][0];
    ans[0][1] = cost[0][1];
    ans[0][2] = cost[0][2];


    for(int i = 1; i < N; i++){
        ans[i][0] = cost[i][0] + min({ans[i - 1][1], ans[i - 1][2]}); // i번째 집을 0으로 칠하는 경우, 최소값은
        // 이전 집이 1 또는 2 일때 중 최소값에 계속 더하기
        ans[i][1] = cost[i][1] + min({ans[i - 1][0], ans[i - 1][2]});
        ans[i][2] = cost[i][2] + min({ans[i - 1][0], ans[i - 1][1]});
    }

    cout << min({ans[N - 1][0], ans[N - 1][1], ans[N - 1][2]});


}